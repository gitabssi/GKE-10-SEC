apiVersion: apps/v1
kind: Deployment
metadata:
  name: fraud-api-simple
  namespace: fraud-detection
spec:
  replicas: 1
  selector:
    matchLabels:
      app: fraud-api-simple
  template:
    metadata:
      labels:
        app: fraud-api-simple
    spec:
      containers:
      - name: fraud-api
        image: python:3.11-slim
        ports:
        - containerPort: 8000
        env:
        - name: GEMINI_API_KEY
          value: "AIzaSyB5tZVwZeHJX6GwRE7duXQRo0IKWjXJdm4"
        command: ["/bin/bash", "-c"]
        args:
        - |
          pip install fastapi uvicorn google-generativeai requests
          mkdir -p /app && cd /app
          cat > main.py << 'EOF'
          from fastapi import FastAPI
          from pydantic import BaseModel
          import google.generativeai as genai
          import os
          import json
          from datetime import datetime
          import logging

          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)

          GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "")
          if GEMINI_API_KEY:
              try:
                  genai.configure(api_key=GEMINI_API_KEY)
                  model = genai.GenerativeModel('gemini-1.5-flash')
                  logger.info("âœ… Gemini AI configured successfully")
              except Exception as e:
                  logger.error(f"âŒ Gemini AI configuration failed: {e}")
                  model = None
          else:
              logger.warning("âš ï¸ Gemini API key not found")
              model = None

          app = FastAPI(title="AI Fraud Detection API", version="1.0.0")

          class TransactionRequest(BaseModel):
              transactionId: str
              amount: float
              timestamp: str
              userId: str
              merchantId: str = "unknown"
              location: str = "unknown"

          @app.get("/")
          async def root():
              return {
                  "service": "AI Fraud Detection API",
                  "version": "1.0.0",
                  "status": "running",
                  "gemini_configured": model is not None
              }

          @app.get("/health")
          async def health():
              return {"status": "healthy", "gemini_configured": model is not None}

          @app.post("/analyze")
          async def analyze_transaction(transaction: TransactionRequest):
              start_time = datetime.utcnow()
              
              try:
                  logger.info(f"Analyzing transaction {transaction.transactionId}")
                  
                  if not model:
                      # Fallback analysis
                      fraud_score = min(transaction.amount / 5000, 0.95)
                      risk_level = "HIGH" if fraud_score > 0.7 else "MEDIUM" if fraud_score > 0.4 else "LOW"
                      
                      return {
                          "transactionId": transaction.transactionId,
                          "fraud_score": fraud_score,
                          "risk_level": risk_level,
                          "confidence": 0.7,
                          "explanation": f"Fallback analysis: Amount-based risk assessment (${transaction.amount})",
                          "recommendation": "REVIEW" if fraud_score > 0.5 else "APPROVE",
                          "processing_time_ms": (datetime.utcnow() - start_time).total_seconds() * 1000,
                          "ai_powered": False
                      }
                  
                  # AI analysis
                  prompt = f"""
                  Analyze this transaction for fraud:
                  Amount: ${transaction.amount}
                  User: {transaction.userId}
                  Merchant: {transaction.merchantId}
                  Location: {transaction.location}
                  
                  Return JSON:
                  {{
                      "fraud_score": 0.0-1.0,
                      "risk_level": "LOW|MEDIUM|HIGH",
                      "confidence": 0.0-1.0,
                      "explanation": "reasoning",
                      "recommendation": "APPROVE|REVIEW|BLOCK"
                  }}
                  """
                  
                  response = model.generate_content(prompt)
                  
                  try:
                      json_start = response.text.find('{')
                      json_end = response.text.rfind('}') + 1
                      ai_result = json.loads(response.text[json_start:json_end])
                  except:
                      fraud_score = min(transaction.amount / 3000, 0.9)
                      ai_result = {
                          "fraud_score": fraud_score,
                          "risk_level": "HIGH" if fraud_score > 0.7 else "MEDIUM",
                          "confidence": 0.8,
                          "explanation": f"AI analysis: Transaction amount ${transaction.amount} analyzed",
                          "recommendation": "REVIEW" if fraud_score > 0.5 else "APPROVE"
                      }
                  
                  processing_time = (datetime.utcnow() - start_time).total_seconds() * 1000
                  
                  return {
                      "transactionId": transaction.transactionId,
                      "fraud_score": ai_result.get("fraud_score", 0.5),
                      "risk_level": ai_result.get("risk_level", "MEDIUM"),
                      "confidence": ai_result.get("confidence", 0.8),
                      "explanation": ai_result.get("explanation", "AI-powered analysis"),
                      "recommendation": ai_result.get("recommendation", "REVIEW"),
                      "processing_time_ms": processing_time,
                      "ai_powered": True
                  }
                  
              except Exception as e:
                  logger.error(f"Analysis failed: {str(e)}")
                  return {
                      "transactionId": transaction.transactionId,
                      "fraud_score": 0.5,
                      "risk_level": "MEDIUM",
                      "confidence": 0.3,
                      "explanation": f"Analysis error: {str(e)}",
                      "recommendation": "REVIEW",
                      "processing_time_ms": (datetime.utcnow() - start_time).total_seconds() * 1000,
                      "ai_powered": False
                  }

          if __name__ == "__main__":
              import uvicorn
              logger.info("ðŸš€ Starting Fraud Detection API")
              uvicorn.run(app, host="0.0.0.0", port=8000)
          EOF
          python main.py
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "250m"
---
apiVersion: v1
kind: Service
metadata:
  name: fraud-api-simple
  namespace: fraud-detection
spec:
  type: LoadBalancer
  selector:
    app: fraud-api-simple
  ports:
  - name: http
    port: 8000
    targetPort: 8000
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fraud-dashboard-simple
  namespace: fraud-detection
spec:
  replicas: 1
  selector:
    matchLabels:
      app: fraud-dashboard-simple
  template:
    metadata:
      labels:
        app: fraud-dashboard-simple
    spec:
      containers:
      - name: fraud-dashboard
        image: python:3.11-slim
        ports:
        - containerPort: 8501
        command: ["/bin/bash", "-c"]
        args:
        - |
          pip install streamlit requests plotly pandas
          mkdir -p /app && cd /app
          cat > dashboard.py << 'EOF'
          import streamlit as st
          import requests
          import json
          import time
          from datetime import datetime
          import plotly.graph_objects as go

          st.set_page_config(page_title="AI Fraud Detection", page_icon="ðŸš¨", layout="wide")
          st.title("ðŸš¨ AI Fraud Detection Dashboard")
          st.subheader("GKE Turns 10 Hackathon - Real-time AI Analysis")

          FRAUD_API_URL = "http://fraud-api-simple.fraud-detection.svc.cluster.local:8000"

          # Sidebar
          st.sidebar.header("ðŸ§ª Test Transaction")
          transaction_id = st.sidebar.text_input("Transaction ID", f"txn_{int(time.time())}")
          amount = st.sidebar.number_input("Amount ($)", min_value=0.01, value=100.0)
          user_id = st.sidebar.text_input("User ID", "user123")
          merchant_id = st.sidebar.text_input("Merchant ID", "merchant456")
          location = st.sidebar.text_input("Location", "New York, NY")

          if st.sidebar.button("ðŸ” Analyze Transaction"):
              with st.spinner("ðŸ¤– Analyzing with AI..."):
                  try:
                      response = requests.post(f"{FRAUD_API_URL}/analyze", json={
                          "transactionId": transaction_id,
                          "amount": amount,
                          "timestamp": datetime.utcnow().isoformat(),
                          "userId": user_id,
                          "merchantId": merchant_id,
                          "location": location
                      }, timeout=30)
                      
                      if response.status_code == 200:
                          result = response.json()
                          
                          col1, col2, col3 = st.columns(3)
                          with col1:
                              st.metric("Fraud Score", f"{result['fraud_score']:.3f}")
                          with col2:
                              st.metric("Risk Level", result['risk_level'])
                          with col3:
                              st.metric("Confidence", f"{result['confidence']:.3f}")
                          
                          # Gauge chart
                          fig = go.Figure(go.Indicator(
                              mode = "gauge+number",
                              value = result['fraud_score'] * 100,
                              title = {'text': "Fraud Risk %"},
                              gauge = {
                                  'axis': {'range': [None, 100]},
                                  'bar': {'color': "darkblue"},
                                  'steps': [
                                      {'range': [0, 30], 'color': "lightgreen"},
                                      {'range': [30, 70], 'color': "yellow"},
                                      {'range': [70, 100], 'color': "red"}
                                  ]
                              }
                          ))
                          st.plotly_chart(fig, use_container_width=True)
                          
                          st.subheader("ðŸ” Analysis")
                          st.write(result['explanation'])
                          
                          st.subheader("ðŸ’¡ Recommendation")
                          if result['recommendation'] == 'APPROVE':
                              st.success(f"âœ… {result['recommendation']}")
                          elif result['recommendation'] == 'REVIEW':
                              st.warning(f"âš ï¸ {result['recommendation']}")
                          else:
                              st.error(f"ðŸš« {result['recommendation']}")
                          
                          ai_mode = "ðŸ¤– Gemini AI" if result.get('ai_powered') else "ðŸ”§ Fallback"
                          st.info(f"Analysis: {ai_mode} | Time: {result['processing_time_ms']:.1f}ms")
                          
                      else:
                          st.error(f"API Error: {response.status_code}")
                  except Exception as e:
                      st.error(f"Connection error: {str(e)}")

          # Demo scenarios
          st.header("ðŸŽ¯ Demo Scenarios")
          col1, col2, col3 = st.columns(3)
          
          with col1:
              if st.button("â˜• Coffee ($4.50)"):
                  st.write("Normal transaction - Expected: LOW risk")
                  
          with col2:
              if st.button("ðŸ’³ Large Purchase ($2500)"):
                  st.write("Suspicious amount - Expected: HIGH risk")
                  
          with col3:
              if st.button("ðŸŒ International ($850)"):
                  st.write("International transaction - Expected: MEDIUM risk")

          # System status
          st.header("ðŸ”§ System Status")
          try:
              health = requests.get(f"{FRAUD_API_URL}/health", timeout=5)
              if health.status_code == 200:
                  data = health.json()
                  st.success("âœ… API: Online")
                  if data.get('gemini_configured'):
                      st.success("âœ… Gemini AI: Connected")
                  else:
                      st.warning("âš ï¸ Gemini AI: Fallback mode")
              else:
                  st.error("âŒ API: Offline")
          except:
              st.error("âŒ Cannot connect to API")

          st.markdown("---")
          st.markdown("**GKE Turns 10 Hackathon** | AI Fraud Detection | Google Gemini")
          EOF
          streamlit run dashboard.py --server.port=8501 --server.address=0.0.0.0
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "250m"
---
apiVersion: v1
kind: Service
metadata:
  name: fraud-dashboard-simple
  namespace: fraud-detection
spec:
  type: LoadBalancer
  selector:
    app: fraud-dashboard-simple
  ports:
  - name: http
    port: 8501
    targetPort: 8501
