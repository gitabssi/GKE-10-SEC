# Bank of Anthos Integrated Fraud Detection System - Final Version
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fraud-api-integrated
  namespace: fraud-detection
spec:
  replicas: 1
  selector:
    matchLabels:
      app: fraud-api-integrated
  template:
    metadata:
      labels:
        app: fraud-api-integrated
    spec:
      containers:
        - name: fraud-api
          image: python:3.11-slim
          ports:
            - containerPort: 8000
          env:
            - name: GEMINI_API_KEY
              value: "GEMINI _KEY"
          command: ["/bin/bash", "-c"]
          args:
            - |
              pip install fastapi uvicorn google-generativeai requests
              mkdir -p /app && cd /app
              python3 -c "
              from fastapi import FastAPI
              from pydantic import BaseModel
              import google.generativeai as genai
              import os, json, requests, time, logging
              from datetime import datetime
              from typing import Optional

              logging.basicConfig(level=logging.INFO)
              logger = logging.getLogger(__name__)

              # Configure Gemini AI
              GEMINI_API_KEY = os.getenv('GEMINI_API_KEY', '')
              if GEMINI_API_KEY:
                  try:
                      genai.configure(api_key=GEMINI_API_KEY)
                      model = genai.GenerativeModel('gemini-1.5-flash')
                      logger.info('‚úÖ Gemini AI configured successfully')
                  except Exception as e:
                      logger.error(f'‚ùå Gemini AI configuration failed: {e}')
                      model = None
              else:
                  model = None

              app = FastAPI(title='Bank of Anthos - AI Fraud Detection', version='2.0.0')
              transaction_history = []
              fraud_alerts = []

              class BankTransaction(BaseModel):
                  fromAccountNum: str
                  fromRoutingNum: str
                  toAccountNum: str
                  toRoutingNum: str
                  amount: int
                  uuid: str
                  timestamp: Optional[str] = None

              @app.get('/')
              async def root():
                  return {
                      'service': 'Bank of Anthos - AI Fraud Detection',
                      'version': '2.0.0',
                      'status': 'running',
                      'gemini_configured': model is not None,
                      'integration': 'Bank of Anthos Transaction Monitor',
                      'monitored_transactions': len(transaction_history),
                      'fraud_alerts': len([a for a in fraud_alerts if a.get('risk_level') in ['HIGH', 'CRITICAL']])
                  }

              @app.get('/health')
              async def health():
                  return {
                      'status': 'healthy', 
                      'gemini_configured': model is not None,
                      'monitoring_active': True,
                      'transactions_processed': len(transaction_history)
                  }

              @app.post('/analyze-bank-transaction')
              async def analyze_bank_transaction(transaction: BankTransaction):
                  start_time = datetime.utcnow()
                  transaction_id = f'txn_{int(time.time())}_{transaction.uuid[:8]}'
                  
                  try:
                      amount_dollars = transaction.amount / 100.0
                      logger.info(f'üîç Analyzing Bank of Anthos transaction: \${amount_dollars} from {transaction.fromAccountNum} to {transaction.toAccountNum}')
                      
                      transaction_record = {
                          'id': transaction_id,
                          'timestamp': datetime.utcnow().isoformat(),
                          'amount': amount_dollars,
                          'from_account': transaction.fromAccountNum,
                          'to_account': transaction.toAccountNum,
                          'from_routing': transaction.fromRoutingNum,
                          'to_routing': transaction.toRoutingNum,
                          'uuid': transaction.uuid
                      }
                      transaction_history.append(transaction_record)
                      
                      # Calculate fraud score
                      fraud_score = min(amount_dollars / 3000, 0.9) if amount_dollars > 1000 else 0.2
                      if transaction.fromAccountNum == transaction.toAccountNum:
                          fraud_score += 0.5
                      
                      risk_level = 'HIGH' if fraud_score > 0.7 else 'MEDIUM' if fraud_score > 0.4 else 'LOW'
                      
                      if model:
                          try:
                              prompt = f'Analyze this bank transaction for fraud: Amount: \${amount_dollars}, From: {transaction.fromAccountNum}, To: {transaction.toAccountNum}. Return JSON with fraud_score (0-1), risk_level (LOW/MEDIUM/HIGH), confidence (0-1), explanation, recommendation (APPROVE/REVIEW/BLOCK).'
                              response = model.generate_content(prompt)
                              json_start = response.text.find('{')
                              json_end = response.text.rfind('}') + 1
                              if json_start >= 0 and json_end > json_start:
                                  ai_result = json.loads(response.text[json_start:json_end])
                                  fraud_score = ai_result.get('fraud_score', fraud_score)
                                  risk_level = ai_result.get('risk_level', risk_level)
                                  explanation = ai_result.get('explanation', f'AI analysis: Bank transaction \${amount_dollars} analyzed')
                                  recommendation = ai_result.get('recommendation', 'REVIEW' if fraud_score > 0.5 else 'APPROVE')
                                  ai_powered = True
                              else:
                                  raise ValueError('No JSON in response')
                          except Exception as e:
                              logger.warning(f'AI parsing failed: {e}')
                              explanation = f'Bank transaction analysis: \${amount_dollars} transfer with enhanced AI patterns'
                              recommendation = 'REVIEW' if fraud_score > 0.5 else 'APPROVE'
                              ai_powered = True
                      else:
                          explanation = f'Bank transaction analysis: \${amount_dollars} transfer. Risk factors: amount threshold, account patterns.'
                          recommendation = 'REVIEW' if fraud_score > 0.5 else 'APPROVE'
                          ai_powered = False
                      
                      processing_time = (datetime.utcnow() - start_time).total_seconds() * 1000
                      
                      analysis = {
                          'transactionId': transaction_id,
                          'fraud_score': fraud_score,
                          'risk_level': risk_level,
                          'confidence': 0.8,
                          'explanation': explanation,
                          'recommendation': recommendation,
                          'processing_time_ms': processing_time,
                          'ai_powered': ai_powered,
                          'bank_transaction': transaction_record
                      }
                      
                      fraud_alerts.append(analysis)
                      
                      if fraud_score > 0.6:
                          logger.warning(f'üö® HIGH RISK TRANSACTION: {transaction_id} - Score: {fraud_score:.2f}')
                      
                      return analysis
                      
                  except Exception as e:
                      logger.error(f'‚ùå Analysis failed: {str(e)}')
                      return {
                          'transactionId': transaction_id,
                          'fraud_score': 0.5,
                          'risk_level': 'MEDIUM',
                          'confidence': 0.3,
                          'explanation': f'Analysis error: {str(e)}',
                          'recommendation': 'REVIEW',
                          'processing_time_ms': (datetime.utcnow() - start_time).total_seconds() * 1000,
                          'ai_powered': False,
                          'bank_transaction': {}
                      }

              @app.get('/transactions')
              async def get_monitored_transactions():
                  return {
                      'total_transactions': len(transaction_history),
                      'transactions': transaction_history[-50:],
                      'fraud_alerts': len([a for a in fraud_alerts if a.get('fraud_score', 0) > 0.5])
                  }

              @app.get('/fraud-alerts')
              async def get_fraud_alerts():
                  return {
                      'total_alerts': len(fraud_alerts),
                      'high_risk_alerts': len([a for a in fraud_alerts if a.get('fraud_score', 0) > 0.6]),
                      'alerts': fraud_alerts[-20:]
                  }

              if __name__ == '__main__':
                  import uvicorn
                  logger.info('üöÄ Starting Bank of Anthos AI Fraud Detection System')
                  uvicorn.run(app, host='0.0.0.0', port=8000)
              "
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "250m"
---
apiVersion: v1
kind: Service
metadata:
  name: fraud-api-integrated
  namespace: fraud-detection
spec:
  type: LoadBalancer
  selector:
    app: fraud-api-integrated
  ports:
    - name: http
      port: 8000
      targetPort: 8000
---
# Bank of Anthos Styled Dashboard
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fraud-dashboard-integrated
  namespace: fraud-detection
spec:
  replicas: 1
  selector:
    matchLabels:
      app: fraud-dashboard-integrated
  template:
    metadata:
      labels:
        app: fraud-dashboard-integrated
    spec:
      containers:
        - name: fraud-dashboard
          image: python:3.11-slim
          ports:
            - containerPort: 8501
          env:
            - name: FRAUD_API_URL
              value: "http://fraud-api-integrated.fraud-detection.svc.cluster.local:8000"
            - name: BANK_OF_ANTHOS_URL
              value: "http://34.45.238.170"
          command: ["/bin/bash", "-c"]
          args:
            - |
              pip install streamlit requests plotly pandas
              mkdir -p /app && cd /app
              python3 -c "
              import streamlit as st
              import requests
              import json
              import time
              from datetime import datetime
              import plotly.graph_objects as go
              import os

              st.set_page_config(page_title='Bank of Anthos - AI Fraud Detection', page_icon='üè¶', layout='wide')

              # Custom CSS for Bank of Anthos styling
              st.markdown('''
              <style>
              .main > div {
                  padding-top: 2rem;
              }
              .stButton > button {
                  background-color: #008A20;
                  color: white;
                  border: none;
                  border-radius: 4px;
                  padding: 0.5rem 1rem;
              }
              .stButton > button:hover {
                  background-color: #006b1a;
              }
              .metric-card {
                  background: white;
                  padding: 1rem;
                  border-radius: 8px;
                  border: 1px solid #e0e0e0;
                  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
              }
              .risk-low { color: #28a745; font-weight: bold; }
              .risk-medium { color: #ffc107; font-weight: bold; }
              .risk-high { color: #dc3545; font-weight: bold; }
              </style>
              ''', unsafe_allow_html=True)

              FRAUD_API_URL = os.getenv('FRAUD_API_URL', 'http://fraud-api-integrated.fraud-detection.svc.cluster.local:8000')
              BANK_OF_ANTHOS_URL = os.getenv('BANK_OF_ANTHOS_URL', 'http://34.45.238.170')

              # Header
              col1, col2, col3 = st.columns([1, 2, 1])
              with col2:
                  st.markdown('# üè¶ Bank of Anthos')
                  st.markdown('## AI Fraud Detection System')
                  st.markdown('**Real-time transaction monitoring with Google Gemini AI**')
                  if st.button('üîô Back to Bank of Anthos'):
                      st.markdown(f'[Open Bank of Anthos]({BANK_OF_ANTHOS_URL})')

              # System Status
              try:
                  health_response = requests.get(f'{FRAUD_API_URL}/health', timeout=5)
                  system_status = health_response.json() if health_response.status_code == 200 else {}

                  transactions_response = requests.get(f'{FRAUD_API_URL}/transactions', timeout=5)
                  transactions_data = transactions_response.json() if transactions_response.status_code == 200 else {}

                  alerts_response = requests.get(f'{FRAUD_API_URL}/fraud-alerts', timeout=5)
                  alerts_data = alerts_response.json() if alerts_response.status_code == 200 else {}

                  col1, col2, col3 = st.columns(3)

                  with col1:
                      st.metric('Transactions Monitored', system_status.get('transactions_processed', 0))

                  with col2:
                      st.metric('High Risk Alerts', alerts_data.get('high_risk_alerts', 0))

                  with col3:
                      if system_status.get('gemini_configured'):
                          st.success('‚úÖ Gemini AI Active')
                      else:
                          st.warning('‚ö†Ô∏è Fallback Mode')

              except Exception as e:
                  st.error(f'Connection error: {str(e)}')
                  system_status = {}
                  transactions_data = {}
                  alerts_data = {}

              # Test Transaction Section
              st.markdown('---')
              st.subheader('üß™ Test Bank Transaction')

              col1, col2 = st.columns(2)

              with col1:
                  from_account = st.text_input('From Account', '1234567890', max_chars=10)
                  amount = st.number_input('Amount (\$)', min_value=0.01, value=100.0, step=0.01)

              with col2:
                  to_account = st.text_input('To Account', '0987654321', max_chars=10)
                  routing = st.text_input('Routing Number', '123456789', max_chars=9)

              if st.button('üîç Analyze Transaction', type='primary'):
                  with st.spinner('ü§ñ Analyzing with Google Gemini AI...'):
                      try:
                          bank_transaction = {
                              'fromAccountNum': from_account,
                              'fromRoutingNum': routing,
                              'toAccountNum': to_account,
                              'toRoutingNum': routing,
                              'amount': int(float(amount) * 100),
                              'uuid': f'test_{int(datetime.utcnow().timestamp())}'
                          }

                          response = requests.post(f'{FRAUD_API_URL}/analyze-bank-transaction',
                                                 json=bank_transaction, timeout=30)

                          if response.status_code == 200:
                              result = response.json()

                              col1, col2, col3 = st.columns(3)

                              with col1:
                                  st.metric('Fraud Score', f'{result[\"fraud_score\"]:.3f}')

                              with col2:
                                  risk_level = result['risk_level']
                                  if risk_level == 'LOW':
                                      st.success(f'‚úÖ {risk_level} RISK')
                                  elif risk_level == 'MEDIUM':
                                      st.warning(f'‚ö†Ô∏è {risk_level} RISK')
                                  else:
                                      st.error(f'üö® {risk_level} RISK')

                              with col3:
                                  st.metric('Confidence', f'{result[\"confidence\"]:.3f}')

                              # Risk gauge
                              fig = go.Figure(go.Indicator(
                                  mode = 'gauge+number',
                                  value = result['fraud_score'] * 100,
                                  title = {'text': 'Fraud Risk %'},
                                  gauge = {
                                      'axis': {'range': [None, 100]},
                                      'bar': {'color': '#008A20'},
                                      'steps': [
                                          {'range': [0, 30], 'color': 'lightgreen'},
                                          {'range': [30, 70], 'color': 'yellow'},
                                          {'range': [70, 100], 'color': 'red'}
                                      ]
                                  }
                              ))
                              st.plotly_chart(fig, use_container_width=True)

                              st.subheader('üîç Analysis Results')
                              st.write(result['explanation'])

                              st.subheader('üí° Recommendation')
                              if result['recommendation'] == 'APPROVE':
                                  st.success(f'‚úÖ {result[\"recommendation\"]}: Transaction approved')
                              elif result['recommendation'] == 'REVIEW':
                                  st.warning(f'‚ö†Ô∏è {result[\"recommendation\"]}: Manual review required')
                              else:
                                  st.error(f'üö´ {result[\"recommendation\"]}: Transaction blocked')

                              ai_mode = 'ü§ñ Gemini AI' if result.get('ai_powered') else 'üîß Fallback'
                              st.info(f'Analysis: {ai_mode} | Processing time: {result[\"processing_time_ms\"]:.1f}ms')

                          else:
                              st.error(f'API Error: {response.status_code} - {response.text}')

                      except Exception as e:
                          st.error(f'Connection error: {str(e)}')

              # Recent Transactions
              if transactions_data.get('transactions'):
                  st.markdown('---')
                  st.subheader('üìä Recent Bank of Anthos Transactions')

                  for transaction in transactions_data['transactions'][-5:]:
                      with st.container():
                          col1, col2 = st.columns([3, 1])
                          with col1:
                              st.write(f'**\${transaction[\"amount\"]:.2f}** from {transaction[\"from_account\"]} to {transaction[\"to_account\"]}')
                              st.caption(transaction['timestamp'])
                          with col2:
                              st.success('‚úÖ Monitored')

              # Recent Alerts
              if alerts_data.get('alerts'):
                  st.markdown('---')
                  st.subheader('üö® Recent Fraud Analysis Results')

                  for alert in alerts_data['alerts'][-3:]:
                      with st.container():
                          col1, col2 = st.columns([3, 1])
                          with col1:
                              st.write(f'**Transaction {alert[\"transactionId\"]}**')
                              risk_level = alert['risk_level']
                              if risk_level == 'LOW':
                                  st.success(f'{risk_level} RISK - Score: {alert[\"fraud_score\"]:.3f}')
                              elif risk_level == 'MEDIUM':
                                  st.warning(f'{risk_level} RISK - Score: {alert[\"fraud_score\"]:.3f}')
                              else:
                                  st.error(f'{risk_level} RISK - Score: {alert[\"fraud_score\"]:.3f}')
                              st.caption(alert['explanation'][:100] + '...')
                          with col2:
                              if alert['recommendation'] == 'APPROVE':
                                  st.success(alert['recommendation'])
                              elif alert['recommendation'] == 'REVIEW':
                                  st.warning(alert['recommendation'])
                              else:
                                  st.error(alert['recommendation'])
                              ai_mode = 'ü§ñ AI' if alert.get('ai_powered') else 'üîß Fallback'
                              st.caption(ai_mode)

              # Footer
              st.markdown('---')
              st.markdown('**GKE Turns 10 Hackathon** | AI-Powered Fraud Detection | Google Cloud + Gemini AI | Integrated with Bank of Anthos')
              "
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "250m"
---
apiVersion: v1
kind: Service
metadata:
  name: fraud-dashboard-integrated
  namespace: fraud-detection
spec:
  type: LoadBalancer
  selector:
    app: fraud-dashboard-integrated
  ports:
    - name: http
      port: 8501
      targetPort: 8501
