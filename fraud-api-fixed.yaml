# Bank of Anthos Fraud Detection API - Fixed Version
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fraud-api-integrated
  namespace: fraud-detection
spec:
  replicas: 1
  selector:
    matchLabels:
      app: fraud-api-integrated
  template:
    metadata:
      labels:
        app: fraud-api-integrated
    spec:
      containers:
        - name: fraud-api
          image: python:3.11-slim
          ports:
            - containerPort: 8000
          env:
            - name: GEMINI_API_KEY
              value: "AIzaSyD-b4t-UzGxFIdrnrnSn6e7ZM2TwlsV18w"
            - name: BANK_OF_ANTHOS_FRONTEND_URL
              value: "http://frontend.default.svc.cluster.local"
            - name: LEDGERWRITER_URL
              value: "http://ledgerwriter.default.svc.cluster.local:8080"
          command: ["/bin/bash", "-c"]
          args:
            - |
              pip install fastapi uvicorn google-generativeai requests
              mkdir -p /app && cd /app
              cat > main.py << 'EOF'
              from fastapi import FastAPI, HTTPException
              from pydantic import BaseModel
              import google.generativeai as genai
              import json
              import logging
              import os
              import requests
              from datetime import datetime
              from typing import List, Optional
              import time

              logging.basicConfig(level=logging.INFO)
              logger = logging.getLogger(__name__)

              # Configure Gemini AI
              GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "")
              if GEMINI_API_KEY:
                  try:
                      genai.configure(api_key=GEMINI_API_KEY)
                      model = genai.GenerativeModel('gemini-1.5-flash')
                      logger.info("‚úÖ Gemini AI configured successfully")
                  except Exception as e:
                      logger.error(f"‚ùå Gemini AI configuration failed: {e}")
                      model = None
              else:
                  logger.warning("‚ö†Ô∏è Gemini API key not found")
                  model = None

              app = FastAPI(title="Bank of Anthos - AI Fraud Detection", version="2.0.0")

              # In-memory storage for transaction monitoring
              transaction_history = []
              fraud_alerts = []

              class BankTransaction(BaseModel):
                  fromAccountNum: str
                  fromRoutingNum: str
                  toAccountNum: str
                  toRoutingNum: str
                  amount: int  # Amount in cents
                  uuid: str

              class FraudAnalysis(BaseModel):
                  transactionId: str
                  fraud_score: float
                  risk_level: str
                  confidence: float
                  explanation: str
                  recommendation: str
                  processing_time_ms: float
                  ai_powered: bool
                  bank_transaction: dict

              def calculate_bank_fraud_score(transaction):
                  score = 0.0
                  amount = transaction["amount"]
                  
                  # Amount-based risk
                  if amount >= 100000000:  # $1M+
                      score += 0.9
                  elif amount >= 1000000:  # $10K+
                      score += 0.6
                  elif amount >= 100000:  # $1K+
                      score += 0.3
                  elif amount >= 10000:  # $100+
                      score += 0.1
                  
                  # Cross-bank transfer risk
                  if transaction["from_routing"] != transaction["to_routing"]:
                      score += 0.2
                  
                  return min(score, 1.0)

              def get_risk_level(fraud_score):
                  if fraud_score >= 0.8:
                      return "HIGH"
                  elif fraud_score >= 0.5:
                      return "MEDIUM"
                  else:
                      return "LOW"

              @app.get("/")
              async def root():
                  return {
                      "service": "Bank of Anthos - AI Fraud Detection",
                      "version": "2.0.0",
                      "status": "running",
                      "gemini_configured": model is not None,
                      "integration": "Bank of Anthos Transaction Monitor",
                      "monitored_transactions": len(transaction_history),
                      "fraud_alerts": len([a for a in fraud_alerts if a['risk_level'] in ['HIGH', 'CRITICAL']])
                  }

              @app.get("/health")
              async def health():
                  return {
                      "status": "healthy",
                      "gemini_configured": model is not None,
                      "monitoring_active": True,
                      "transactions_processed": len(transaction_history)
                  }

              @app.get("/transactions")
              async def get_transactions():
                  """Return all stored transactions with fraud analysis"""
                  return {
                      "transactions": transaction_history,
                      "total_count": len(transaction_history),
                      "fraud_alerts": len([t for t in transaction_history if t.get('fraud_analysis', {}).get('risk_level') in ['HIGH', 'CRITICAL']])
                  }

              @app.get("/alerts")
              async def get_alerts():
                  """Return fraud alerts"""
                  return {
                      "alerts": fraud_alerts,
                      "total_count": len(fraud_alerts)
                  }

              @app.post("/clear-transactions")
              async def clear_transactions():
                  """Clear all stored transactions and alerts - useful for demo reset"""
                  global transaction_history, fraud_alerts
                  cleared_count = len(transaction_history)
                  transaction_history.clear()
                  fraud_alerts.clear()
                  logger.info(f"üßπ CLEARED {cleared_count} transactions and alerts for demo reset")
                  return {
                      "success": True,
                      "message": f"Cleared {cleared_count} transactions and alerts",
                      "remaining_transactions": len(transaction_history),
                      "remaining_alerts": len(fraud_alerts)
                  }

              @app.post("/analyze-bank-transaction")
              async def analyze_bank_transaction(transaction: BankTransaction):
                  try:
                      start_time = datetime.utcnow()
                      transaction_id = transaction.uuid
                      amount_dollars = transaction.amount / 100.0
                      
                      logger.info(f"üîç Analyzing Bank of Anthos transaction: {transaction_id} - ${amount_dollars:.2f}")
                      
                      # Store transaction record
                      transaction_record = {
                          "id": transaction_id,
                          "timestamp": start_time.isoformat(),
                          "amount": amount_dollars,
                          "from_account": transaction.fromAccountNum,
                          "to_account": transaction.toAccountNum,
                          "from_routing": transaction.fromRoutingNum,
                          "to_routing": transaction.toRoutingNum,
                          "uuid": transaction.uuid
                      }
                      transaction_history.append(transaction_record)
                      
                      # Try Gemini AI first, fallback to enhanced analysis if needed
                      gemini_analysis = None
                      if model:
                          try:
                              # AI-powered analysis with banking context
                              prompt = f"""
                              You are analyzing a real Bank of Anthos transaction for fraud detection:
                              
                              Transaction Details:
                              - Amount: ${amount_dollars}
                              - From Account: {transaction.fromAccountNum}
                              - To Account: {transaction.toAccountNum}
                              - From Routing: {transaction.fromRoutingNum}
                              - To Routing: {transaction.toRoutingNum}
                              - Transaction UUID: {transaction.uuid}
                              
                              Banking Context:
                              - This is a real banking transaction from Bank of Anthos
                              - Internal routing number indicates local bank transfers
                              - Account numbers are 10-digit bank account identifiers
                              
                              Analyze for fraud patterns and provide detailed reasoning:
                              {{
                                  "fraud_score": 0.0-1.0,
                                  "risk_level": "LOW|MEDIUM|HIGH|CRITICAL",
                                  "confidence": 0.0-1.0,
                                  "explanation": "Detailed analysis of banking transaction patterns, risk factors, and reasoning",
                                  "recommendation": "APPROVE|REVIEW|BLOCK",
                                  "risk_factors": ["list", "of", "specific", "risk", "factors"]
                              }}
                              """
                              
                              response = model.generate_content(prompt)
                              gemini_text = response.text.strip()
                              
                              # Try to parse JSON response
                              if gemini_text.startswith('```json'):
                                  gemini_text = gemini_text.replace('```json', '').replace('```', '').strip()
                              elif gemini_text.startswith('```'):
                                  gemini_text = gemini_text.replace('```', '').strip()
                              
                              gemini_analysis = json.loads(gemini_text)
                              logger.info(f"‚úÖ Gemini AI analysis successful for {transaction_id}")
                              
                          except Exception as e:
                              logger.warning(f"‚ö†Ô∏è Gemini AI analysis failed for {transaction_id}: {str(e)}")
                              gemini_analysis = None
                      
                      if gemini_analysis:
                          # Use Gemini AI results
                          analysis = FraudAnalysis(
                              transactionId=transaction_id,
                              fraud_score=float(gemini_analysis.get('fraud_score', 0.5)),
                              risk_level=gemini_analysis.get('risk_level', 'MEDIUM'),
                              confidence=float(gemini_analysis.get('confidence', 0.8)),
                              explanation=gemini_analysis.get('explanation', 'AI analysis completed'),
                              recommendation=gemini_analysis.get('recommendation', 'REVIEW'),
                              processing_time_ms=(datetime.utcnow() - start_time).total_seconds() * 1000,
                              ai_powered=True,
                              bank_transaction=transaction_record
                          )
                      else:
                          # Enhanced fallback analysis for bank transactions
                          fraud_score = calculate_bank_fraud_score(transaction_record)
                          risk_level = get_risk_level(fraud_score)
                          
                          # Generate detailed fallback explanation
                          risk_factors = []
                          explanation_parts = []
                          
                          if amount_dollars >= 1000000:
                              risk_factors.append("extremely large amount")
                              explanation_parts.append(f"The transaction involves an extremely large amount (${amount_dollars:,.2f}) which is highly unusual for most personal or even small business accounts.")
                          elif amount_dollars >= 10000:
                              risk_factors.append("large amount")
                              explanation_parts.append(f"The transaction amount (${amount_dollars:,.2f}) is significant and warrants additional scrutiny.")
                          elif amount_dollars >= 1000:
                              risk_factors.append("moderate amount")
                              explanation_parts.append(f"The transaction amount (${amount_dollars:,.2f}) is within normal ranges but requires monitoring.")
                          else:
                              explanation_parts.append(f"The transaction amount (${amount_dollars:,.2f}) is relatively small, reducing immediate fraud risk.")
                          
                          if transaction.fromRoutingNum != transaction.toRoutingNum:
                              risk_factors.append("cross-bank transfer")
                              explanation_parts.append("This is a cross-bank transfer which may require additional verification.")
                          else:
                              explanation_parts.append("This is an internal bank transfer within the same institution.")
                          
                          if fraud_score > 0.7:
                              explanation_parts.append("Multiple risk factors indicate this transaction should be blocked pending manual review.")
                          elif fraud_score > 0.4:
                              explanation_parts.append("Some risk indicators suggest this transaction should be reviewed by fraud analysts.")
                          else:
                              explanation_parts.append("The transaction appears to have low fraud risk based on available patterns.")
                          
                          detailed_explanation = " ".join(explanation_parts)
                          
                          analysis = FraudAnalysis(
                              transactionId=transaction_id,
                              fraud_score=fraud_score,
                              risk_level=risk_level,
                              confidence=0.75,
                              explanation=detailed_explanation,
                              recommendation="BLOCK" if fraud_score > 0.7 else "REVIEW" if fraud_score > 0.4 else "APPROVE",
                              processing_time_ms=(datetime.utcnow() - start_time).total_seconds() * 1000,
                              ai_powered=False,
                              bank_transaction=transaction_record
                          )
                      
                      # Store fraud analysis
                      fraud_alerts.append(analysis.dict())

                      # Add fraud analysis to the transaction record
                      transaction_record["fraud_analysis"] = {
                          "fraud_score": analysis.fraud_score,
                          "risk_level": analysis.risk_level,
                          "confidence": analysis.confidence,
                          "explanation": analysis.explanation,
                          "recommendation": analysis.recommendation,
                          "ai_powered": analysis.ai_powered,
                          "processing_time_ms": analysis.processing_time_ms
                      }

                      # Log high-risk transactions
                      if analysis.fraud_score > 0.6:
                          logger.warning(f"üö® HIGH RISK TRANSACTION: {transaction_id} - Score: {analysis.fraud_score:.2f}")

                      return analysis
                      
                  except Exception as e:
                      logger.error(f"‚ùå Bank transaction analysis failed: {str(e)}")
                      processing_time = (datetime.utcnow() - start_time).total_seconds() * 1000
                      
                      return FraudAnalysis(
                          transactionId=transaction_id,
                          fraud_score=0.5,
                          risk_level="MEDIUM",
                          confidence=0.5,
                          explanation=f"Analysis error: {str(e)}",
                          recommendation="REVIEW",
                          processing_time_ms=processing_time,
                          ai_powered=False,
                          bank_transaction=transaction_record
                      )

              if __name__ == "__main__":
                  import uvicorn
                  logger.info("üöÄ Starting Bank of Anthos Fraud Detection API")
                  uvicorn.run(app, host="0.0.0.0", port=8000)
              EOF

              python main.py
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "250m"
---
apiVersion: v1
kind: Service
metadata:
  name: fraud-api-integrated
  namespace: fraud-detection
spec:
  type: LoadBalancer
  selector:
    app: fraud-api-integrated
  ports:
    - name: http
      port: 8000
      targetPort: 8000
